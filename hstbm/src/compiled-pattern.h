/* compiled-pattern -- Broker module for users of tokenised patterns

   Copyright (C) 1988, 1998, 2000, 2002, 2004-2005, 2007-2015 Free Software
   Foundation, Inc.
   Copyright (C) 2015 Grouse Software

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA */

/*
   This module acts as the central broker for all modules that work
   with compiled patterns (tokenised, plus token-related resources,
   possibly plus additional information to summarise content).

   It gathers pieces that describe patterns (token opcodes/params
   from pattern-lex, charclass lists, and, in the future, other
   pattern items such as wide-char descriptions), provides resources
   for managing memory for these resources in cases where the
   original provider doesn't supply the service or uses a different,
   inconvenient and/or hidden storage layout, and presents the
   integrated whole to consumers such as pattern
   analysis/optimisation services, and various search engines.

   This module's origins can partially, if not mostly, be traced
   back to the code in GNU Grep, especially dfa.c.  The contributors
   to that file are many and varied; an early copyright notice is:

          Written June, 1988 by Mike Haertel
          Modified July, 1988 by Arthur David Olson to assist
          BMG speedups

   In addition, many, many others have contributed to GNU Grep in
   ways that are recorded in various places, including the AUTHORS
   file and version control changelogs.  This module is a descendent
   of the GNU Grep files, and all the contributors are gratefully
   acknowledged here.

   This variant written in 2014-2015 by behoffski (Brenton Hoff)
   of Grouse Software.
*/

#ifndef COMPILED_PATTERN_H
#define COMPILED_PATTERN_H 1

#include "charclass.h"
#include "pattern-lex.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Fairly loose, sloppy structure collecting low-to-mid-level data
   structures and information generated by the lexer (and possibly
   a parser, in the future).

   I initially didn't want to create this level of
   structure/packaging, but reluctantly decided to add it late in
   the development cycle, so that all dynamic memory allocated
   during operation had an explicit free during shutdown, thereby
   keeping Valgrind happy.  It's quite possible that this structure
   belongs elsewhere, and/or that its contents should be hidden.
   Data hiding would lead to more cumbersome manipuulation of the
   structure in some cases, but would mean that we rely less on the
   client(s) for critical issues such as memory management.  */
typedef struct compiled_pattern_struct {
  /* Pattern length, in octets.  While a user could derive the
     length for a simple pattern by analysing the token list
     opcodes, it's easier to compute the value once, and then store
     it here.  This value only makes sense for simple patterns
     (e.g. no variable-length repeats, optional items, alternation,
     backreferences); for the initial, embryonic code, this
     constraint is met.  */
  /* ?? REVIEWME:  If this code is extended to accommodate
     variable-length patterns, then perhaps pattern_len should be
     set to 0 as a sentinel.  */
  int pattern_len;

  /* Tokenised representation of the pattern.  This includes lexemes
     such as CHAR_CLASS to replace multi-character pattern
     components with fixed-length tokens with opcodes (+ parameters
     as appropriate).  At a more general level, the dividing line
     between lexing and parsing could be considered blurry; I'm
     interested in clarifying this boundary, but it's in the
     "too-hard" bucket at present, as hstbm only deals with linear
     patterns, and a little-or-no-parsing implementation is
     sufficient.  */
  int nr_tokens;
  pattern_lex_token_t *token_list;

  /* Data structures associated with, and possibly indirectly or
     directly referenced by, the token list.  */

  /* List of charclasses for this pattern, one per position (even
     where a class is overkill, such as CHAR_DIRECT tokens).  The
     reason for this arrangement is that some pattern analysis is
     much easier to do with charclass (unary) representation.  The
     number of classes is the same as pattern_len.  */
  charclass_t **charclass_list;

} compiled_pattern_t;

/* Prepare module for operation.  */
extern void
compiled_pattern_initialise (void);

/* Allocate a compiled_pattern instance, including naming an upper
   bound on pattern size.  Other structures in the instance are
   assigned memory based on this value; regrettably, managing the
   memory footprint of the instance, shared by various modules, is
   only on an honour system, and is open to abuse.  On the upside,
   the instance bundles together a set of closely-related
   structures, and so makes life easier when used correctly.

   The function returns NULL if it is unable to serve the
   request.  */
extern compiled_pattern_t *
compiled_pattern_alloc (int pattern_len);

/* ?? NOTE: Public declaration of compiled_pattern_discard omitted
   for the present... all instances will be bulk-discarded when the
   module is destroyed.  */

/* Check that the supplied compiled pattern is a valid instance of
   this module, and throw an assertion if anything is found to be
   amiss.  */
extern void
compiled_pattern_check (compiled_pattern_t *compiled_pattern);

/* Provide a human-readable description of the compiled pattern;
   typically one line per token, with extra information showing
   details of some tokens (e.g. charclass set membership).  The
   description is written into a static buffer, which is returned to
   the caller; thus, this function isn't reentrant.  */
extern char *
compiled_pattern_describe (compiled_pattern_t *compiled_pattern);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* COMPILED_PATTERN_H */
/* vim:set shiftwidth=2: */
